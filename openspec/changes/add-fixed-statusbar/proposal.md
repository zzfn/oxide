# Proposal: 添加固定底部状态栏

## 概述

为 Oxide CLI 添加固定在终端底部的状态栏，使用 ANSI 转义序列实现原地更新，显示实时信息（如 Token 使用量、会话状态等），同时保持对话历史在上方滚动区域正常显示。

## 动机

当前 Oxide CLI 的所有输出（包括状态信息）都混在对话流中，随着对话进行向上滚动。用户需要：

1. **实时状态可见性**：随时查看 Token 使用量、会话信息等，无需回滚历史
2. **清晰的信息分层**：对话内容与状态信息分离，提升可读性
3. **专业的终端体验**：类似 htop、vim 等工具的固定状态栏效果

## 目标

1. 实现固定在终端底部的状态栏，不随对话滚动
2. 使用 ANSI 转义序列（光标定位、屏幕区域划分）实现原地更新
3. 显示关键信息：Token 使用量、会话 ID、当前模型、工作目录等
4. 支持动态更新（如 Token 计数实时变化）
5. 保持现有对话流的正常显示和滚动

## 非目标

- 不实现复杂的多行状态栏（仅单行或最多两行）
- 不支持鼠标交互
- 不改变现有的 Markdown 渲染逻辑

## 技术方案

### 核心技术

使用 ANSI 转义序列控制终端：

1. **屏幕区域划分**：
   - `\x1b[1;{height-1}r` - 设置滚动区域（第 1 行到倒数第 2 行）
   - 底部 1-2 行保留给状态栏

2. **光标操作**：
   - `\x1b[s` - 保存光标位置
   - `\x1b[{row};{col}H` - 移动光标到指定位置
   - `\x1b[u` - 恢复光标位置

3. **渲染流程**：
   - 初始化时设置滚动区域
   - 更新状态栏：保存光标 → 跳到底部 → 绘制状态栏 → 恢复光标
   - 对话内容在滚动区域正常输出

### 实现模块

在 `src/cli/statusbar.rs` 中实现：

```rust
pub struct StatusBar {
    enabled: bool,
    terminal_height: u16,
    // 状态数据
}

impl StatusBar {
    pub fn new() -> Self;
    pub fn init(&mut self) -> Result<()>;  // 设置滚动区域
    pub fn update(&self, data: &StatusData) -> Result<()>;  // 更新显示
    pub fn cleanup(&self) -> Result<()>;  // 恢复终端状态
}
```

### 集成点

1. **OxideCli 初始化**：创建 StatusBar 实例并调用 `init()`
2. **Token 更新**：在 `stream_with_animation` 中更新 Token 计数后刷新状态栏
3. **退出清理**：在 `run()` 结束时调用 `cleanup()`

## 依赖

- 已有依赖 `crossterm` (v0.29) - 提供终端尺寸查询和 ANSI 支持
- 无需新增依赖

## 风险与缓解

| 风险 | 影响 | 缓解措施 |
|------|------|----------|
| 终端不支持 ANSI | 状态栏显示异常 | 检测终端能力，不支持时禁用状态栏 |
| 终端尺寸变化 | 状态栏位置错误 | 监听 SIGWINCH 信号，动态调整 |
| 与现有输出冲突 | 显示混乱 | 确保所有输出都通过统一的渲染层 |

## 替代方案

1. **使用 tui-rs/ratatui**：过于重量级，需要重构整个 UI
2. **仅在顶部显示状态**：无法固定，会随对话滚动
3. **使用独立窗口/tmux pane**：增加复杂度，用户体验不佳

## 成功标准

- [ ] 状态栏固定在终端底部，不随对话滚动
- [ ] Token 使用量实时更新
- [ ] 对话历史正常显示和滚动
- [ ] 终端尺寸变化时自动适配
- [ ] 退出时正确恢复终端状态
- [ ] 不支持 ANSI 的终端优雅降级

## 时间线

按 `tasks.md` 中的任务顺序实施。
